var P=Object.defineProperty;var U=(i,n,t)=>n in i?P(i,n,{enumerable:!0,configurable:!0,writable:!0,value:t}):i[n]=t;var u=(i,n,t)=>(U(i,typeof n!="symbol"?n+"":n,t),t),w=(i,n,t)=>{if(!n.has(i))throw TypeError("Cannot "+t)};var h=(i,n,t)=>(w(i,n,"read from private field"),t?t.call(i):n.get(i)),p=(i,n,t)=>{if(n.has(i))throw TypeError("Cannot add the same private member more than once");n instanceof WeakSet?n.add(i):n.set(i,t)},m=(i,n,t,e)=>(w(i,n,"write to private field"),e?e.call(i,t):n.set(i,t),t);var C=(i,n,t)=>(w(i,n,"access private method"),t);import{w as b,g as f,W as I,_ as A,h as _}from"./index.fcc556b6.js";import{W,U as v,C as x,A as D,S as R}from"./errors-9fc48fb5.browser.esm.28f782e3.js";import{n as E}from"./normalizeChainId-e4cc0175.browser.esm.042707b7.js";var d,l,g,y;class N extends W{constructor(t){let{chains:e,options:s}=t;super({chains:e,options:{reloadOnDisconnect:!1,...s}});p(this,g);u(this,"id",b.coinbase);u(this,"name","Coinbase Wallet");u(this,"ready",!0);p(this,d,void 0);p(this,l,void 0);u(this,"onAccountsChanged",t=>{t.length===0?this.emit("disconnect"):this.emit("change",{account:f(t[0])})});u(this,"onChainChanged",t=>{const e=E(t),s=this.isChainUnsupported(e);this.emit("change",{chain:{id:e,unsupported:s}})});u(this,"onDisconnect",()=>{this.emit("disconnect")})}async connect(){let{chainId:t}=arguments.length>0&&arguments[0]!==void 0?arguments[0]:{};try{const e=await this.getProvider();this.setupListeners(),this.emit("message",{type:"connecting"});const s=await e.enable(),o=f(s[0]);let r=await this.getChainId(),c=this.isChainUnsupported(r);if(t&&r!==t)try{r=(await this.switchChain(t)).chainId,c=this.isChainUnsupported(r)}catch(a){console.error(`Connected but failed to switch to desired chain ${t}`,a)}return{account:o,chain:{id:r,unsupported:c},provider:new I(e)}}catch(e){throw/(user closed modal|accounts received is empty)/i.test(e.message)?new v(e):e}}async disconnect(){if(!h(this,l))return;const t=await this.getProvider();t.removeListener("accountsChanged",this.onAccountsChanged),t.removeListener("chainChanged",this.onChainChanged),t.removeListener("disconnect",this.onDisconnect),t.disconnect(),t.close()}async getAccount(){const e=await(await this.getProvider()).request({method:"eth_accounts"});if(e.length===0)throw new Error("No accounts found");return f(e[0])}async getChainId(){const t=await this.getProvider();return E(t.chainId)}async getProvider(){var t;if(!h(this,l)){let e=(await A(()=>import("./index.66ec0d48.js").then(a=>a.i),["assets/index.66ec0d48.js","assets/index.fcc556b6.js","assets/index.62fde1f8.css","assets/index.ae094b69.js"])).default;typeof e!="function"&&typeof e.default=="function"&&(e=e.default),m(this,d,new e(this.options));const s=(t=h(this,d).walletExtension)==null?void 0:t.getChainId(),o=this.chains.find(a=>this.options.chainId?a.chainId===this.options.chainId:a.chainId===s)||this.chains[0],r=this.options.chainId||(o==null?void 0:o.chainId),c=this.options.jsonRpcUrl||(o==null?void 0:o.rpc[0]);m(this,l,h(this,d).makeWeb3Provider(c,r))}return h(this,l)}async getSigner(){let{chainId:t}=arguments.length>0&&arguments[0]!==void 0?arguments[0]:{};const[e,s]=await Promise.all([this.getProvider(),this.getAccount()]);return new I(e,t).getSigner(s)}async isAuthorized(){try{return!!await this.getAccount()}catch{return!1}}async switchChain(t){var o;const e=await this.getProvider(),s=_(t);try{return await e.request({method:"wallet_switchEthereumChain",params:[{chainId:s}]}),(o=this.chains.find(r=>r.chainId===t))!=null?o:{chainId:t,name:`Chain ${s}`,slug:`${s}`,nativeCurrency:{name:"Ether",decimals:18,symbol:"ETH"},rpc:[""],testnet:!1,chain:"ethereum",shortName:"eth"}}catch(r){const c=this.chains.find(a=>a.chainId===t);if(!c)throw new x({chainId:t,connectorId:this.id});if(r.code===4902)try{return await e.request({method:"wallet_addEthereumChain",params:[{chainId:s,chainName:c.name,nativeCurrency:c.nativeCurrency,rpcUrls:c.rpc,blockExplorerUrls:this.getBlockExplorerUrls(c)}]}),c}catch(a){throw C(this,g,y).call(this,a)?new v(a):new D}throw C(this,g,y).call(this,r)?new v(r):new R(r)}}async setupListeners(){const t=await this.getProvider();t.on("accountsChanged",this.onAccountsChanged),t.on("chainChanged",this.onChainChanged),t.on("disconnect",this.onDisconnect)}async getQrUrl(){if(await this.getProvider(),!h(this,d))throw new Error("Coinbase Wallet SDK not initialized");return h(this,d).getQrUrl()}}d=new WeakMap,l=new WeakMap,g=new WeakSet,y=function(t){return/(user rejected)/i.test(t.message)};export{N as CoinbaseWalletConnector};
