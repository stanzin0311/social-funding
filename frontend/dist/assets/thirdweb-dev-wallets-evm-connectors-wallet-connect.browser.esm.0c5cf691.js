var B=Object.defineProperty;var F=(r,a,t)=>a in r?B(r,a,{enumerable:!0,configurable:!0,writable:!0,value:t}):r[a]=t;var p=(r,a,t)=>(F(r,typeof a!="symbol"?a+"":a,t),t),U=(r,a,t)=>{if(!a.has(r))throw TypeError("Cannot "+t)};var i=(r,a,t)=>(U(r,a,"read from private field"),t?t.call(r):a.get(r)),d=(r,a,t)=>{if(a.has(r))throw TypeError("Cannot add the same private member more than once");a instanceof WeakSet?a.add(r):a.set(r,t)},N=(r,a,t,s)=>(U(r,a,"write to private field"),s?s.call(r,t):a.set(r,t),t);var c=(r,a,t)=>(U(r,a,"access private method"),t);import{w as G,g as q,W as H,h as k,_ as X}from"./index.fcc556b6.js";import{W as Z,U as V,S as J}from"./errors-9fc48fb5.browser.esm.28f782e3.js";const tt=new Set([1,137,10,42161,56]),Q="eip155",z="wagmi.requestedChains",L="wallet_addEthereumChain",O="last-used-chain-id";var n,C,m,I,T,D,K,E,b,_,j,g,y,P,x,S,R,A,W;class nt extends Z{constructor(t){super({...t,options:{isNewChainsStale:!0,...t.options}});d(this,I);d(this,D);d(this,E);d(this,_);d(this,g);d(this,P);d(this,S);d(this,A);p(this,"id",G.walletConnect);p(this,"name","WalletConnect");p(this,"ready",!0);d(this,n,void 0);d(this,C,void 0);d(this,m,void 0);p(this,"onAccountsChanged",t=>{t.length===0?this.emit("disconnect"):this.emit("change",{account:q(t[0])})});p(this,"onChainChanged",async t=>{const s=Number(t),o=this.isChainUnsupported(s);await i(this,m).setItem(O,String(t)),this.emit("change",{chain:{id:s,unsupported:o}})});p(this,"onDisconnect",async()=>{await c(this,g,y).call(this,[]),await i(this,m).removeItem(O),this.emit("disconnect")});p(this,"onDisplayUri",t=>{this.emit("message",{type:"display_uri",data:t})});p(this,"onConnect",()=>{this.emit("connect",{provider:i(this,n)})});N(this,m,t.options.storage),c(this,I,T).call(this),this.filteredChains=this.chains.length>50?this.chains.filter(s=>tt.has(s.chainId)):this.chains}async connect(){var o;let{chainId:t,pairingTopic:s}=arguments.length>0&&arguments[0]!==void 0?arguments[0]:{};try{let e=t;if(!e){const v=await i(this,m).getItem(O),l=v?parseInt(v):void 0;l&&!this.isChainUnsupported(l)?e=l:e=(o=this.filteredChains[0])==null?void 0:o.chainId}if(!e)throw new Error("No chains found on connector.");const h=await this.getProvider();this.setupListeners();const u=await c(this,E,b).call(this);if(h.session&&u&&await h.disconnect(),!h.session||u){const v=this.filteredChains.filter(l=>l.chainId!==e).map(l=>l.chainId);this.emit("message",{type:"connecting"}),await h.connect({pairingTopic:s,chains:[e],optionalChains:v.length>0?v:[e]}),await c(this,g,y).call(this,this.filteredChains.map(l=>{let{chainId:$}=l;return $}))}const w=await h.enable();if(w.length===0)throw new Error("No accounts found on provider.");const M=q(w[0]),f=await this.getChainId(),Y=this.isChainUnsupported(f);return{account:M,chain:{id:f,unsupported:Y},provider:new H(h)}}catch(e){throw/user rejected/i.test(e==null?void 0:e.message)?new V(e):e}}async disconnect(){const t=()=>{if(!(typeof localStorage>"u"))for(const e in localStorage)e.startsWith("wc@2")&&localStorage.removeItem(e)};t();const s=await this.getProvider();(async()=>{try{await s.disconnect()}catch(e){if(!/No matching key/i.test(e.message))throw e}finally{c(this,_,j).call(this),await c(this,g,y).call(this,[]),t()}})()}async getAccount(){const{accounts:t}=await this.getProvider();if(t.length===0)throw new Error("No accounts found on provider.");return q(t[0])}async getChainId(){const{chainId:t}=await this.getProvider();return t}async getProvider(){let{chainId:t}=arguments.length>0&&arguments[0]!==void 0?arguments[0]:{};if(i(this,n)||await c(this,I,T).call(this),t&&await this.switchChain(t),!i(this,n))throw new Error("No provider found.");return i(this,n)}async getSigner(){let{chainId:t}=arguments.length>0&&arguments[0]!==void 0?arguments[0]:{};const[s,o]=await Promise.all([this.getProvider({chainId:t}),this.getAccount()]);return new H(s,t).getSigner(o)}async isAuthorized(){try{const[t,s]=await Promise.all([this.getAccount(),this.getProvider()]),o=await c(this,E,b).call(this);if(!t)return!1;if(o&&s.session){try{await s.disconnect()}catch{}return!1}return!0}catch{return!1}}async switchChain(t){var o;const s=this.chains.find(e=>e.chainId===t);if(!s)throw new J(`Chain with ID: ${t}, not found on connector.`);try{const e=await this.getProvider(),h=c(this,S,R).call(this),u=c(this,A,W).call(this);if(!h.includes(t)&&u.includes(L)){const M=(o=s.explorers)!=null&&o.length?{blockExplorerUrls:[s.explorers[0].url]}:{};await e.request({method:L,params:[{chainId:k(s.chainId),chainName:s.name,nativeCurrency:s.nativeCurrency,rpcUrls:[...s.rpc],...M}]});const f=await c(this,P,x).call(this);f.push(t),await c(this,g,y).call(this,f)}return await e.request({method:"wallet_switchEthereumChain",params:[{chainId:k(t)}]}),s}catch(e){const h=typeof e=="string"?e:e==null?void 0:e.message;throw/user rejected request/i.test(h)?new V(e):new J(e)}}async setupListeners(){!i(this,n)||(c(this,_,j).call(this),i(this,n).on("accountsChanged",this.onAccountsChanged),i(this,n).on("chainChanged",this.onChainChanged),i(this,n).on("disconnect",this.onDisconnect),i(this,n).on("session_delete",this.onDisconnect),i(this,n).on("display_uri",this.onDisplayUri),i(this,n).on("connect",this.onConnect))}}n=new WeakMap,C=new WeakMap,m=new WeakMap,I=new WeakSet,T=async function(){return i(this,C)||N(this,C,c(this,D,K).call(this)),i(this,C)},D=new WeakSet,K=async function(){const{default:t,OPTIONAL_EVENTS:s,OPTIONAL_METHODS:o}=await X(()=>import("./index.es.c7721442.js"),["assets/index.es.c7721442.js","assets/index.fcc556b6.js","assets/index.62fde1f8.css","assets/index.ae094b69.js"]),[e,...h]=this.filteredChains.map(u=>{let{chainId:w}=u;return w});e&&N(this,n,await t.init({showQrModal:this.options.qrcode!==!1,projectId:this.options.projectId,optionalMethods:o,optionalEvents:s,chains:[e],optionalChains:h,metadata:{name:this.options.dappMetadata.name,description:this.options.dappMetadata.description||"",url:this.options.dappMetadata.url,icons:[this.options.dappMetadata.logoUrl||""]},rpcMap:Object.fromEntries(this.filteredChains.map(u=>[u.chainId,u.rpc[0]])),qrModalOptions:this.options.qrModalOptions}))},E=new WeakSet,b=async function(){if(c(this,A,W).call(this).includes(L)||!this.options.isNewChainsStale)return!1;const s=await c(this,P,x).call(this),o=this.filteredChains.map(h=>{let{chainId:u}=h;return u}),e=c(this,S,R).call(this);return e.length&&!e.some(h=>o.includes(h))?!1:!o.every(h=>s.includes(h))},_=new WeakSet,j=function(){!i(this,n)||(i(this,n).removeListener("accountsChanged",this.onAccountsChanged),i(this,n).removeListener("chainChanged",this.onChainChanged),i(this,n).removeListener("disconnect",this.onDisconnect),i(this,n).removeListener("session_delete",this.onDisconnect),i(this,n).removeListener("display_uri",this.onDisplayUri),i(this,n).removeListener("connect",this.onConnect))},g=new WeakSet,y=async function(t){await i(this,m).setItem(z,JSON.stringify(t))},P=new WeakSet,x=async function(){const t=await i(this,m).getItem(z);return t?JSON.parse(t):[]},S=new WeakSet,R=function(){var s,o,e;if(!i(this,n))return[];const t=(e=(o=(s=i(this,n).session)==null?void 0:s.namespaces[Q])==null?void 0:o.chains)==null?void 0:e.map(h=>parseInt(h.split(":")[1]||""));return t!=null?t:[]},A=new WeakSet,W=function(){var s,o;if(!i(this,n))return[];const t=(o=(s=i(this,n).session)==null?void 0:s.namespaces[Q])==null?void 0:o.methods;return t!=null?t:[]};export{nt as WalletConnectConnector};
